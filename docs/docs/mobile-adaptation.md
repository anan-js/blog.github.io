---
title: 移动端适配相关知识详解
tags:
  - 移动端
createTime: 2024/08/31 18:08:14
permalink: /article/eefh9rq8/
---
# 移动端适配相关知识详解

## 1. 什么是移动端适配



两个重要概念：



- **自适应**：依据不同的设备屏幕大小，自动对尺寸、大小进行调整。  
- **响应式**：能够随着屏幕的实时变化而自动调整，是自适应的一种特殊情况。

## 2. 理解视口 viewport

### 2.1 PC 端的视口



在浏览器中，我们所能看到的区域即为视口（viewport），`fixed` 定位就是相对于视口来进行的。在 PC 端的页面中，无需对视口进行区分，因为布局视口和视觉视口是同一个。

### 2.2 移动端的视口



移动端的情况有所不同，布局视口和可见的视口是不一样的。这是由于移动端网页窗口通常较小，我们可能期望一个较大的网页能在移动端完整显示。所以在默认情况下，移动端的布局视口是大于视觉视口的。在移动端，我们可以将视口划分为三种情况：



- **布局视口 (layout viewport)**
- **视觉视口 (visuallayout)**
- **理想视口 (ideallayout)**

#### 2.2.0 PC 端的网页在移动端显示的问题



- **PC 端显示**：正常显示网页内容。
- **移动端显示**：同样大小（如 100X100px）的盒子在移动端显示得很小，未显示真正的 100x100px。这是因为 PC 端的页面为了能在移动端完整展示，整个页面会同比例缩小显示。

#### 2.2.1 布局视口



默认情况下，PC 端的网页在移动端会按照宽度为 980px 来布局页面的盒子和内容。为了能完整显示页面内容，会对整个页面进行缩小。我们将相对于 980px 布局的这个视口，称之为布局视口 (layoutviewport) ，布局视口的默认宽度是 980px。所以，如果未对项目进行移动端适配，在手机上打开项目时会将项目同比例缩小。

#### 2.2.2 视觉视口 (visual viewport)



默认情况下，按照 980px 显示内容时，右侧会有一部分区域无法显示，因此手机端浏览器会默认对页面进行缩放，以使其显示在用户的可见区域中。那么，显示在可见区域的这个视口，就是视觉视口 (visual viewport) 。在 Chrome 上按 shift + 鼠标左键可以进行缩放操作。

#### 2.2.3 理想视口 (ideallayout)



如果所有网页都按照 980px 在移动端布局，最终页面都会被缩放显示，这种方式不利于移动端开发。我们期望设置 100px，显示的就是 100px。通过设置理想视口 (ideal viewport) 可以实现这一点，理想视口就是布局视口等于视觉视口 ，反过来说，布局视口等于视觉视口 就是理想视口 。可以通过 `meta` 标签设置布局视口，也可以设置 `meta` 中的 `viewport` ，其值、可能的附加值及描述如下：



| 值            | 可能的附加值                           | 描述                                                         |
| ------------- | -------------------------------------- | ------------------------------------------------------------ |
| width         | 一个正整数，或者字符串 `device-width`  | 定义 viewport 的宽度                                         |
| height        | 一个正整数，或者字符串 `device-height` | 定义 viewport 的高度（未被任何浏览器使用）                   |
| initial-scale | 一个 0.0 和 10.0 之间的正数            | 定义设备宽度与 viewport 大小之间的缩放比例                   |
| maximum-scale | 一个 0.0 和 10.0 之间的正数            | 定义缩放的最大值，必须大于等于 `minimum-scale`，否则表现将不可预测 |
| minimum-scale | 一个 0.0 和 10.0 之间的正数            | 定义缩放的最小值，必须小于等于 `maximum-scale`，否则表现将不可预测 |
| user-scalable | `yes` 或者 `no`                        | 默认为 `yes`，如果设置为 `no`，将无法缩放当前页面，浏览器可以忽略此规则 |



开发时一般的写法：
淘宝网也是类似的写法。

## 3. 移动端适配方案



我们期望在移动端的效果是根据设备的尺寸，文本和盒子能够响应式地放大缩小。比如设置一个 100x100 的盒子：



- 在 375px 的屏幕上显示是 100x100；
- 在 320px 的屏幕上显示是 90+ x 90+；
- 在 414px 的屏幕上显示是 100+ x 100+；
  其他尺寸也是类似，比如 `padding`、`margin`、`border`、`left`，甚至是 `font-size` 等等。



有 4 个方案来处理尺寸：



- **方案一：百分比设置**：由于不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一，在移动端适配中使用非常少，基本不用了解即可。
- **方案二: rem 单位 + 动态 html 的 font-size**：若还不了解 `rem` 等单位，可以先去了解 CSS 布局单位 %，`px`，`em`，`rem`，`vh/wh` 。这里通过为每个不同的屏幕设置不同的根元素（`html`）的 `font-size` 的尺寸，然后用 `rem` 计算出尺寸，来达到响应式的效果。
- **方案三: vw 单位**：这种方案无需设置根元素的 `font-size`，因为 `vw` 本身就是相对于视口的单位。
- **方案四: flex 的弹性布局**

## 4. 适配方案实现方式

### 4.1 rem 单位 + 动态 html 的 font-size (方案一)



`rem` 单位是相对于 `html` 元素的 `font-size` 来设置的，如果要在不同屏幕下有不同的尺寸，可以动态修改 `html` 的 `font-size` 尺寸。在开发中，只需要考虑两个问题：



- 问题一：针对不同的屏幕，设置 `html` 不同的 `font-size`；
- 问题二：将原来要设置的尺寸，转化成 `rem` 单位；



这种方案有三种实现方式：

#### 4.1.1 第一种方式：媒体查询



可以通过媒体查询来设置不同尺寸范围内的屏幕 `html` 的 `font-size` 尺寸，`@media screen and` 开头的语句就是媒体查询语句。`@media` 后面是一个或者多个表达式，如果表达式为真，则应用样式。例如 `@media screen and (min-width:320px)` ，意思是设备宽度小于 320 就选中这个样式。



**媒体查询的缺点**：



- 需要针对不同的屏幕编写大量的媒体查询；
- 如果动态改变尺寸，不会实时进行更新。

#### 4.1.2 用 js 动态获取设备宽度



如果希望实时改变屏幕尺寸时，`font-size` 也能实时更改，可以通过 js 代码实现。方法如下：



- 根据 `html` 的宽度计算出 `font-size` 的大小，并设置到 `html` 上；
- 监听页面的实时改变，并重新设置 `font-size` 的大小到 `html` 上。



默认 `font-size:16px`，所以一开始不用设置。这样就可以实现实时响应式了。

#### 4.1.3 利用第三方库 `lib-flexible` 动态 `font-size`



下载地址：[GitHub - amfe/lib-flexible: 可伸缩布局方案](https://github.com/amfe/lib-flexible)



核心代码和上面写 js 是差不多的，主要它处理一些别的情况，比如屏幕是否支持 0.5px，还有页面跳转问题。效果和上面一样。

#### 4.1.4 rem 单位 - px 转成 rem 的方案



上面已经解决了动态生成 `font-size` 的问题，但是还需要把 `px` 转成 `rem`。在 375px 的屏幕上 `font-size` 就是 37.5，100px 宽的盒子就是 100 除以 37.5，每一次都要运算，比较麻烦。

#### 4.1.5 第一种：手动用计算器算（不推荐）



比如有一个在 375px 屏幕上，100px 宽度和高度的盒子，我们需要将 100px 转成对应的 `rem` 值：
100 / 37.5 = 2.6667，其他尺寸也用相同的方法计算。

#### 4.1.6 第二种：用 `less` 的混合 `scss` 的函数



这种方式比手动计算方便很多，但也不是很好，要写很多的函数名。

#### 4.1.7 第三种：`postcss-pxtorem`



在前端的工程化开发中，可以借助于 `webpack` 的工具来完成自动的转化。例如，设计稿是 375 的，就在 375 上布局写 `px`，之前怎么布局现在就怎么布局，后面打包就会自动修改。



**步骤**：



1. 下载插件：`npm i postcss-pxtorem -D`
2. 插件官网
3. 在根目录下新建一个 `postcss.config.js` 文件，下面提供了一份基本的 PostCSS 示例配置，可以在此配置的基础上根据项目需求进行修改。其他设计稿的可以修改 `rootValue` 的值。

#### 4.1.8 第四种：VSCode 插件



`px to rem` 的插件，在编写时自动转化。然后直接输入 100px 就可以看到，然后选 `rem` 就可以了，不用直接计算。

### 4.2 vw 单位 (方案二)



`vw` 单位是相对于视口的。比如 375px 的屏幕就是 1vw == 3.752px。基于 375 屏幕，效果和前面方案类似，可以从计算样式那里看到 `width` 和 `font-size` 都是动态的。



在 `flexible` GitHub 上已经有写过这样的一句话：“由于 `viewport` 单位得到众多浏览器的兼容， `lib-flexible` 这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用 `viewport` 来代替代此方案。” 所以它更推荐使用 `viewport` 的两个单位 `vw`、`vh`。



`vw` 的兼容性总体来说是不错的。

#### 4.2.1 vw 和 rem 的对比



`rem` 事实上是作为一种过渡的方案，它利用的也是 `vw` 的思想。前面不管是我们自己编写的 `js`，还是 `flexible` 的源码，都是将 1rem 等同于设计稿的 1/10，再利用 1rem 计算相对于整个屏幕的尺寸大小。而 1vw 刚好等于屏幕的 1/100，而且相对于 `rem` 还更加有优势。



`vw` 相比于 `rem` 的优势：



- 优势一：不用去计算 `html` 的 `font-size` 大小，也不需要给 `html` 设置这样一个 `font-size`；
- 优势二：不会因为设置 `html` 的 `font-size` 大小，而必须给 `body` 再设置一个 `font-size`，防止继承；
- 优势三：因为不依赖 `font-size` 的尺寸，所以不用担心某些原因 `html` 的 `font-size` 尺寸被篡改，导致页面尺寸混乱；
- 优势四：`vw` 相比于 `rem` 更加语义化，1vw 刚好是 1/100 的 `viewport` 的大小；
- 优势五：可以具备 `rem` 之前所有的优点。

#### 4.2.2 vw 的单位换算



- **第一种：手动换算**
  比如有一个在 375px 屏幕上，100px 宽度和高度的盒子，我们需要将 100px 转成对应的 `vw` 值：
  100 / 3.75 = 26.667，其他尺寸也用相同的方法计算。
- **第二种：`less/scss` 函数**











```css
@vwUnit:3.75;

.pxToVw(@px) {
  result: 1vw * (@px / @vwUnit);
}

.box {
  width: .pxToVw(100)[result];
  height: .pxToVw(100)[result];
  background-color: orange;
}

p {
  font-size: .pxToVw(14)[result];
}
```







- **第三种：`postcss-px-to-viewport`**
  和 `rem` 一样，在前端的工程化开发中，可以借助于 `webpack` 的工具来完成自动的转化。`postcss-px-to-viewport` 是一款 PostCSS 插件，用于将 `px` 单位转化为 `vw/vh` 单位。



**安装插件**：`npm i postcss-px-to-viewport -D`



下面提供了一份基本的 PostCSS 示例配置，可以在此配置的基础上根据项目需求进行修改。











```css
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-px-to-viewport': {
      viewportWidth: 375,
    },
  },
};
```







`viewportWidth` 的值根据自己的设计稿填写，还有很多配置想看文档配置，比如哪些类不转换 `vw` 等等。



- **第四种：VSCode 插件**
  `px to vw` 的插件，在编写时自动转化，这样就可以实现转换了。
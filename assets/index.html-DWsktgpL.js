import{_ as a,e as i,f as e,o as n}from"./app-DazCwyn3.js";const p={};function l(d,s){return n(),i("div",null,s[0]||(s[0]=[e(`<h2 id="_1-什么是移动端适配" tabindex="-1"><a class="header-anchor" href="#_1-什么是移动端适配"><span>1. 什么是移动端适配</span></a></h2><p>两个重要概念：</p><ul><li><strong>自适应</strong>：依据不同的设备屏幕大小，自动对尺寸、大小进行调整。</li><li><strong>响应式</strong>：能够随着屏幕的实时变化而自动调整，是自适应的一种特殊情况。</li></ul><h2 id="_2-理解视口-viewport" tabindex="-1"><a class="header-anchor" href="#_2-理解视口-viewport"><span>2. 理解视口 viewport</span></a></h2><h3 id="_2-1-pc-端的视口" tabindex="-1"><a class="header-anchor" href="#_2-1-pc-端的视口"><span>2.1 PC 端的视口</span></a></h3><p>在浏览器中，我们所能看到的区域即为视口（viewport），<code>fixed</code> 定位就是相对于视口来进行的。在 PC 端的页面中，无需对视口进行区分，因为布局视口和视觉视口是同一个。</p><h3 id="_2-2-移动端的视口" tabindex="-1"><a class="header-anchor" href="#_2-2-移动端的视口"><span>2.2 移动端的视口</span></a></h3><p>移动端的情况有所不同，布局视口和可见的视口是不一样的。这是由于移动端网页窗口通常较小，我们可能期望一个较大的网页能在移动端完整显示。所以在默认情况下，移动端的布局视口是大于视觉视口的。在移动端，我们可以将视口划分为三种情况：</p><ul><li><strong>布局视口 (layout viewport)</strong></li><li><strong>视觉视口 (visuallayout)</strong></li><li><strong>理想视口 (ideallayout)</strong></li></ul><h4 id="_2-2-0-pc-端的网页在移动端显示的问题" tabindex="-1"><a class="header-anchor" href="#_2-2-0-pc-端的网页在移动端显示的问题"><span>2.2.0 PC 端的网页在移动端显示的问题</span></a></h4><ul><li><strong>PC 端显示</strong>：正常显示网页内容。</li><li><strong>移动端显示</strong>：同样大小（如 100X100px）的盒子在移动端显示得很小，未显示真正的 100x100px。这是因为 PC 端的页面为了能在移动端完整展示，整个页面会同比例缩小显示。</li></ul><h4 id="_2-2-1-布局视口" tabindex="-1"><a class="header-anchor" href="#_2-2-1-布局视口"><span>2.2.1 布局视口</span></a></h4><p>默认情况下，PC 端的网页在移动端会按照宽度为 980px 来布局页面的盒子和内容。为了能完整显示页面内容，会对整个页面进行缩小。我们将相对于 980px 布局的这个视口，称之为布局视口 (layoutviewport) ，布局视口的默认宽度是 980px。所以，如果未对项目进行移动端适配，在手机上打开项目时会将项目同比例缩小。</p><h4 id="_2-2-2-视觉视口-visual-viewport" tabindex="-1"><a class="header-anchor" href="#_2-2-2-视觉视口-visual-viewport"><span>2.2.2 视觉视口 (visual viewport)</span></a></h4><p>默认情况下，按照 980px 显示内容时，右侧会有一部分区域无法显示，因此手机端浏览器会默认对页面进行缩放，以使其显示在用户的可见区域中。那么，显示在可见区域的这个视口，就是视觉视口 (visual viewport) 。在 Chrome 上按 shift + 鼠标左键可以进行缩放操作。</p><h4 id="_2-2-3-理想视口-ideallayout" tabindex="-1"><a class="header-anchor" href="#_2-2-3-理想视口-ideallayout"><span>2.2.3 理想视口 (ideallayout)</span></a></h4><p>如果所有网页都按照 980px 在移动端布局，最终页面都会被缩放显示，这种方式不利于移动端开发。我们期望设置 100px，显示的就是 100px。通过设置理想视口 (ideal viewport) 可以实现这一点，理想视口就是布局视口等于视觉视口 ，反过来说，布局视口等于视觉视口 就是理想视口 。可以通过 <code>meta</code> 标签设置布局视口，也可以设置 <code>meta</code> 中的 <code>viewport</code> ，其值、可能的附加值及描述如下：</p><table><thead><tr><th>值</th><th>可能的附加值</th><th>描述</th></tr></thead><tbody><tr><td>width</td><td>一个正整数，或者字符串 <code>device-width</code></td><td>定义 viewport 的宽度</td></tr><tr><td>height</td><td>一个正整数，或者字符串 <code>device-height</code></td><td>定义 viewport 的高度（未被任何浏览器使用）</td></tr><tr><td>initial-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义设备宽度与 viewport 大小之间的缩放比例</td></tr><tr><td>maximum-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义缩放的最大值，必须大于等于 <code>minimum-scale</code>，否则表现将不可预测</td></tr><tr><td>minimum-scale</td><td>一个 0.0 和 10.0 之间的正数</td><td>定义缩放的最小值，必须小于等于 <code>maximum-scale</code>，否则表现将不可预测</td></tr><tr><td>user-scalable</td><td><code>yes</code> 或者 <code>no</code></td><td>默认为 <code>yes</code>，如果设置为 <code>no</code>，将无法缩放当前页面，浏览器可以忽略此规则</td></tr></tbody></table><p>开发时一般的写法： 淘宝网也是类似的写法。</p><h2 id="_3-移动端适配方案" tabindex="-1"><a class="header-anchor" href="#_3-移动端适配方案"><span>3. 移动端适配方案</span></a></h2><p>我们期望在移动端的效果是根据设备的尺寸，文本和盒子能够响应式地放大缩小。比如设置一个 100x100 的盒子：</p><ul><li>在 375px 的屏幕上显示是 100x100；</li><li>在 320px 的屏幕上显示是 90+ x 90+；</li><li>在 414px 的屏幕上显示是 100+ x 100+； 其他尺寸也是类似，比如 <code>padding</code>、<code>margin</code>、<code>border</code>、<code>left</code>，甚至是 <code>font-size</code> 等等。</li></ul><p>有 4 个方案来处理尺寸：</p><ul><li><strong>方案一：百分比设置</strong>：由于不同属性的百分比值，相对的可能是不同参照物，所以百分比往往很难统一，在移动端适配中使用非常少，基本不用了解即可。</li><li><strong>方案二: rem 单位 + 动态 html 的 font-size</strong>：若还不了解 <code>rem</code> 等单位，可以先去了解 CSS 布局单位 %，<code>px</code>，<code>em</code>，<code>rem</code>，<code>vh/wh</code> 。这里通过为每个不同的屏幕设置不同的根元素（<code>html</code>）的 <code>font-size</code> 的尺寸，然后用 <code>rem</code> 计算出尺寸，来达到响应式的效果。</li><li><strong>方案三: vw 单位</strong>：这种方案无需设置根元素的 <code>font-size</code>，因为 <code>vw</code> 本身就是相对于视口的单位。</li><li><strong>方案四: flex 的弹性布局</strong></li></ul><h2 id="_4-适配方案实现方式" tabindex="-1"><a class="header-anchor" href="#_4-适配方案实现方式"><span>4. 适配方案实现方式</span></a></h2><h3 id="_4-1-rem-单位-动态-html-的-font-size-方案一" tabindex="-1"><a class="header-anchor" href="#_4-1-rem-单位-动态-html-的-font-size-方案一"><span>4.1 rem 单位 + 动态 html 的 font-size (方案一)</span></a></h3><p><code>rem</code> 单位是相对于 <code>html</code> 元素的 <code>font-size</code> 来设置的，如果要在不同屏幕下有不同的尺寸，可以动态修改 <code>html</code> 的 <code>font-size</code> 尺寸。在开发中，只需要考虑两个问题：</p><ul><li>问题一：针对不同的屏幕，设置 <code>html</code> 不同的 <code>font-size</code>；</li><li>问题二：将原来要设置的尺寸，转化成 <code>rem</code> 单位；</li></ul><p>这种方案有三种实现方式：</p><h4 id="_4-1-1-第一种方式-媒体查询" tabindex="-1"><a class="header-anchor" href="#_4-1-1-第一种方式-媒体查询"><span>4.1.1 第一种方式：媒体查询</span></a></h4><p>可以通过媒体查询来设置不同尺寸范围内的屏幕 <code>html</code> 的 <code>font-size</code> 尺寸，<code>@media screen and</code> 开头的语句就是媒体查询语句。<code>@media</code> 后面是一个或者多个表达式，如果表达式为真，则应用样式。例如 <code>@media screen and (min-width:320px)</code> ，意思是设备宽度小于 320 就选中这个样式。</p><p><strong>媒体查询的缺点</strong>：</p><ul><li>需要针对不同的屏幕编写大量的媒体查询；</li><li>如果动态改变尺寸，不会实时进行更新。</li></ul><h4 id="_4-1-2-用-js-动态获取设备宽度" tabindex="-1"><a class="header-anchor" href="#_4-1-2-用-js-动态获取设备宽度"><span>4.1.2 用 js 动态获取设备宽度</span></a></h4><p>如果希望实时改变屏幕尺寸时，<code>font-size</code> 也能实时更改，可以通过 js 代码实现。方法如下：</p><ul><li>根据 <code>html</code> 的宽度计算出 <code>font-size</code> 的大小，并设置到 <code>html</code> 上；</li><li>监听页面的实时改变，并重新设置 <code>font-size</code> 的大小到 <code>html</code> 上。</li></ul><p>默认 <code>font-size:16px</code>，所以一开始不用设置。这样就可以实现实时响应式了。</p><h4 id="_4-1-3-利用第三方库-lib-flexible-动态-font-size" tabindex="-1"><a class="header-anchor" href="#_4-1-3-利用第三方库-lib-flexible-动态-font-size"><span>4.1.3 利用第三方库 <code>lib-flexible</code> 动态 <code>font-size</code></span></a></h4><p>下载地址：<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener noreferrer">GitHub - amfe/lib-flexible: 可伸缩布局方案</a></p><p>核心代码和上面写 js 是差不多的，主要它处理一些别的情况，比如屏幕是否支持 0.5px，还有页面跳转问题。效果和上面一样。</p><h4 id="_4-1-4-rem-单位-px-转成-rem-的方案" tabindex="-1"><a class="header-anchor" href="#_4-1-4-rem-单位-px-转成-rem-的方案"><span>4.1.4 rem 单位 - px 转成 rem 的方案</span></a></h4><p>上面已经解决了动态生成 <code>font-size</code> 的问题，但是还需要把 <code>px</code> 转成 <code>rem</code>。在 375px 的屏幕上 <code>font-size</code> 就是 37.5，100px 宽的盒子就是 100 除以 37.5，每一次都要运算，比较麻烦。</p><h4 id="_4-1-5-第一种-手动用计算器算-不推荐" tabindex="-1"><a class="header-anchor" href="#_4-1-5-第一种-手动用计算器算-不推荐"><span>4.1.5 第一种：手动用计算器算（不推荐）</span></a></h4><p>比如有一个在 375px 屏幕上，100px 宽度和高度的盒子，我们需要将 100px 转成对应的 <code>rem</code> 值： 100 / 37.5 = 2.6667，其他尺寸也用相同的方法计算。</p><h4 id="_4-1-6-第二种-用-less-的混合-scss-的函数" tabindex="-1"><a class="header-anchor" href="#_4-1-6-第二种-用-less-的混合-scss-的函数"><span>4.1.6 第二种：用 <code>less</code> 的混合 <code>scss</code> 的函数</span></a></h4><p>这种方式比手动计算方便很多，但也不是很好，要写很多的函数名。</p><h4 id="_4-1-7-第三种-postcss-pxtorem" tabindex="-1"><a class="header-anchor" href="#_4-1-7-第三种-postcss-pxtorem"><span>4.1.7 第三种：<code>postcss-pxtorem</code></span></a></h4><p>在前端的工程化开发中，可以借助于 <code>webpack</code> 的工具来完成自动的转化。例如，设计稿是 375 的，就在 375 上布局写 <code>px</code>，之前怎么布局现在就怎么布局，后面打包就会自动修改。</p><p><strong>步骤</strong>：</p><ol><li>下载插件：<code>npm i postcss-pxtorem -D</code></li><li>插件官网</li><li>在根目录下新建一个 <code>postcss.config.js</code> 文件，下面提供了一份基本的 PostCSS 示例配置，可以在此配置的基础上根据项目需求进行修改。其他设计稿的可以修改 <code>rootValue</code> 的值。</li></ol><h4 id="_4-1-8-第四种-vscode-插件" tabindex="-1"><a class="header-anchor" href="#_4-1-8-第四种-vscode-插件"><span>4.1.8 第四种：VSCode 插件</span></a></h4><p><code>px to rem</code> 的插件，在编写时自动转化。然后直接输入 100px 就可以看到，然后选 <code>rem</code> 就可以了，不用直接计算。</p><h3 id="_4-2-vw-单位-方案二" tabindex="-1"><a class="header-anchor" href="#_4-2-vw-单位-方案二"><span>4.2 vw 单位 (方案二)</span></a></h3><p><code>vw</code> 单位是相对于视口的。比如 375px 的屏幕就是 1vw == 3.752px。基于 375 屏幕，效果和前面方案类似，可以从计算样式那里看到 <code>width</code> 和 <code>font-size</code> 都是动态的。</p><p>在 <code>flexible</code> GitHub 上已经有写过这样的一句话：“由于 <code>viewport</code> 单位得到众多浏览器的兼容， <code>lib-flexible</code> 这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用 <code>viewport</code> 来代替代此方案。” 所以它更推荐使用 <code>viewport</code> 的两个单位 <code>vw</code>、<code>vh</code>。</p><p><code>vw</code> 的兼容性总体来说是不错的。</p><h4 id="_4-2-1-vw-和-rem-的对比" tabindex="-1"><a class="header-anchor" href="#_4-2-1-vw-和-rem-的对比"><span>4.2.1 vw 和 rem 的对比</span></a></h4><p><code>rem</code> 事实上是作为一种过渡的方案，它利用的也是 <code>vw</code> 的思想。前面不管是我们自己编写的 <code>js</code>，还是 <code>flexible</code> 的源码，都是将 1rem 等同于设计稿的 1/10，再利用 1rem 计算相对于整个屏幕的尺寸大小。而 1vw 刚好等于屏幕的 1/100，而且相对于 <code>rem</code> 还更加有优势。</p><p><code>vw</code> 相比于 <code>rem</code> 的优势：</p><ul><li>优势一：不用去计算 <code>html</code> 的 <code>font-size</code> 大小，也不需要给 <code>html</code> 设置这样一个 <code>font-size</code>；</li><li>优势二：不会因为设置 <code>html</code> 的 <code>font-size</code> 大小，而必须给 <code>body</code> 再设置一个 <code>font-size</code>，防止继承；</li><li>优势三：因为不依赖 <code>font-size</code> 的尺寸，所以不用担心某些原因 <code>html</code> 的 <code>font-size</code> 尺寸被篡改，导致页面尺寸混乱；</li><li>优势四：<code>vw</code> 相比于 <code>rem</code> 更加语义化，1vw 刚好是 1/100 的 <code>viewport</code> 的大小；</li><li>优势五：可以具备 <code>rem</code> 之前所有的优点。</li></ul><h4 id="_4-2-2-vw-的单位换算" tabindex="-1"><a class="header-anchor" href="#_4-2-2-vw-的单位换算"><span>4.2.2 vw 的单位换算</span></a></h4><ul><li><strong>第一种：手动换算</strong> 比如有一个在 375px 屏幕上，100px 宽度和高度的盒子，我们需要将 100px 转成对应的 <code>vw</code> 值： 100 / 3.75 = 26.667，其他尺寸也用相同的方法计算。</li><li><strong>第二种：<code>less/scss</code> 函数</strong></li></ul><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">@</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">vwUnit</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">:3.75</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-light-font-style:italic;--shiki-dark:#666666;--shiki-dark-font-style:italic;">.</span><span style="--shiki-light:#B31D28;--shiki-light-font-style:italic;--shiki-dark:#FDAEB7;--shiki-dark-font-style:italic;">pxToVw(@px</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">)</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">result</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">vw</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">*</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">(@px</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">/</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">@vwUnit)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">box</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">width</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.pxToVw(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">)[</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">result</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">height</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.pxToVw(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">)[</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">result</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">background-color</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">orange</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">p</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">font-size</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">.pxToVw(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">14</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">)[</span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">result</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">]</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><strong>第三种：<code>postcss-px-to-viewport</code></strong> 和 <code>rem</code> 一样，在前端的工程化开发中，可以借助于 <code>webpack</code> 的工具来完成自动的转化。<code>postcss-px-to-viewport</code> 是一款 PostCSS 插件，用于将 <code>px</code> 单位转化为 <code>vw/vh</code> 单位。</li></ul><p><strong>安装插件</strong>：<code>npm i postcss-px-to-viewport -D</code></p><p>下面提供了一份基本的 PostCSS 示例配置，可以在此配置的基础上根据项目需求进行修改。</p><div class="language-css line-numbers-mode" data-ext="css" data-title="css"><button class="copy" title="复制代码" data-copied="已复制"></button><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">//</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">postcss</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">config</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">js</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">module</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">exports</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">=</span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#998418;--shiki-dark:#B8A965;">plugins</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">:</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">postcss-px-to-viewport</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&#39;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">:</span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">{</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">viewportWidth:</span><span class="space"> </span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">375</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">,</span></span>
<span class="line"><span class="space"> </span><span class="space"> </span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">},</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>viewportWidth</code> 的值根据自己的设计稿填写，还有很多配置想看文档配置，比如哪些类不转换 <code>vw</code> 等等。</p><ul><li><strong>第四种：VSCode 插件</strong><code>px to vw</code> 的插件，在编写时自动转化，这样就可以实现转换了。</li></ul>`,69)]))}const c=a(p,[["render",l],["__file","index.html.vue"]]),o=JSON.parse('{"path":"/article/eefh9rq8/","title":"移动端适配相关知识详解","lang":"zh-CN","frontmatter":{"title":"移动端适配相关知识详解","tags":["移动端"],"createTime":"2024/08/31 18:08:14","permalink":"/article/eefh9rq8/"},"headers":[],"readingTime":{"minutes":9.4,"words":2820},"git":{"updatedTime":1742544334000,"contributors":[{"name":"hello-xiaowu","username":"hello-xiaowu","email":"mvr46tx2fw@privaterelay.appleid.com","commits":2,"avatar":"https://avatars.githubusercontent.com/hello-xiaowu?v=4","url":"https://github.com/hello-xiaowu"}]},"filePathRelative":"docs/mobile-adaptation.md","categoryList":[{"id":"e3e2a9","sort":10000,"name":"docs"}]}');export{c as comp,o as data};
